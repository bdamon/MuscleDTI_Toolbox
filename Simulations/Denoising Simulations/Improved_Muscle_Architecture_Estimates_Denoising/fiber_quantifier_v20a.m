function [angle_list, distance_list, curvature_list, fiber_all_mm, n_points, apo_area] = ...
    fiber_quantifier_v20a(fq_options, fiber_all, roi_mesh, mask)
%
% FUNCTION fiber_quantifier
%  [angle_list, distance_list, curvature_list, fiber_all_mm, n_points, apo_area] = ...
%    fiber_quantifier(fiber_all, roi_mesh, fq_options)
%
% USAGE
%  The function fiber_quantifier is used to calculate the muscle architectural
%  parameters pennation angle, fiber tract length, and curvature in the
%  MuscleDTI_Toolbox.
%
%  The user inputs the fiber tracts generated by fiber_track options, the
%  aponeurosis mesh, and a structure with information about the DTI images and
%  options for implementing the polynomial fitting routines.  Calculations are
%  performed automatically, for tracts having six or more points.  The
%  function returns 1) matrices holding the pennation angles in degrees,
%  curvature values in m^(-1), and cumulative fiber-tract distances in mm at
%  each fiber-tracking point; 2) a version of fiber_all with [row column slice]
%  coordinates converted to mm; 3) the number of points at which architectural
%  calculations were made in each fiber tract (useful for calculating
%  averages, etc.); and 4) an estimate of the aponeurosis area represented by
%  each point on the aponeurosis mesh. Information about each measurement
%  follows:
%    -Fiber tract length: this is measured by summing the inter-point
%     distances along the tract.
%
%    -Pennation: The method for pennation measurements is essentially as
%     described in Lansdown et al, J Appl Physiol 2007. The approach to
%     measuring pennation angle traditionally used in ultrasound imaging is
%     to manually specify the line tangent to a muscle fascicle at the point
%     of its insertion into the aponeurosis and a second line tangent to the
%     aponeurosis. The angle formed by these lines is measured. In Lansdown
%     et al., this concept was extended into 3D space by defining the plane
%     tangent to the seed point and its normal vector. Also, position vectors
%     between the seed point and points along the tract were defined.
%     Pennation angle was defined as the complement to the angle formed by
%     the normal vector and the position vectors. In the toolbox, this is
%     modified slightly to calculated the normal vector as the cross product
%     between two tangent lines to the seed point (one lying in the row
%     direction of the aponeurosis mesh and one lying in the column direction).
%     This change improves computational efficiency.
%
%    -Curvature: The method for curvature measurements is described in Damon
%     et al, Magn Reson Imaging 2012. Briefly, these use a discrete
%     implementation of the Frenet-Serret equations. Specifically, the
%     curvature K is defined in
%       dT/ds = K N
%     where T is the tangent line to points along the curve, s is the step
%     length between points, and N is the normal vector. In fiber_quantifier,
%     K is calculated by multiplying each side of this equation by the Moore-
%     Penrose pseudoinverse matrix of N.
%
%     For curvature, the best results are obtained with polynomial-fitted
%     fiber tracts, calculated using fiber_fitter. Fiber tract length and
%     pennation angle are unaffected by polynomial fitting.
%
% INPUT ARGUMENTS
%  fiber_all: A 4D matrix containing the fiber tract points, with units of
%    pixels (in X and Y) or slice number (in Z).
%
%  roi_mesh: The mesh reconstruction of the aponeurosis that was used as the
%    seed surface for fiber tracking, output from define_roi.
%
%  fq_options: A user-defined structure containing the following fields:
%    dwi_res: a three element vector with the FOV, (assumed to be the same for
%      the x and y directions), in-plane matrix size, and the slice thickness
%      of the DTI images. The FOV and slice thickness must be specified in mm.
%
%    filt_kernel: Pennation angle is calculated as complement to the angle
%      formed by position vectors along the tract and the normal vector to
%      the seed point of the tract. To do so, two lines tangent to the point
%      are calculated. When determining the lines, their slopes are median-
%      filtered over the NxN window specified in filt_kernel; enter this as
%      a single odd integer, e.g. fq_options.filt_kernel=N.  Note that median
%      filtering results in a loss of edge information and that the number of
%      lost rows and columns increases with the size of the filter kernel.
%
%    mesh_units: A two-element string variable set to 'vx' if the units of
%      the aponeurosis  mesh are voxels and set to 'mm' if the roi mesh has
%      units of mm. If set to 'vx', the aponeurosis mesh coordinates are
%      converted to units of mm prior to quantification.
%
%    tract_units: A two-element string variable set to 'vx' if the units of
%      the fiber tracts are voxels and set to 'mm' if the fiber tracts have
%      units of mm. If set to 'vx', the fiber tract coordinates are converted
%      to units of mm prior to quantification.
%
%   seed_method: The method used to seed the points. The method must be
%     specified as a string. The options are:
%       -apo: A mesh reconstruction of the aponeurosis of muscle fiber
%        insertion. If this method is used, the input argument roi_mesh
%        must be included.
%       -column: Tracts are seeded in a user-specified column or columns
%        of the image passing through the muscle mask. The selected
%        column(s) should be included in the field ft_options.planes.
%       -row: Tracts are seeded in a user-specified row or rows of the
%        image passing through the muscle mask. The selected rows should
%        be included in the field ft_options.planes.
%       -slice: Tracts are seeded in a user-specified slice or slices of
%        the image passing through the muscle mask. The selected slices
%        should be included in the field ft_options.planes.
%       -voxels: Tracts are seeded in individual voxels. To seed points in
%        every voxel in the image mask, set ft_options.skip_vxl to 1.  To seed
%        every Nth voxel, set ft_options.skip to N.
%
% OUTPUT ARGUMENTS
%  angle_list: The pennation angles, for fiber tracking point numbers
%    2-end. Pennation angles are reported in degrees.
%
%  distance_list: Distances along the fiber tracts, for fiber tracking point
%    numbers 1-end. Distances are reported in mm.
%
%  curvature_list: The curvature values, for fiber tracking point numbers
%    starting at 2 and ending 3 points before the tract's end. The latter is to
%    avoid abrupt changes in curvature.  Curvature values are reported in m-1.
%
%  fiber_all_mm: The fiber tract points converted to units of mm.
%
%  n_points: A 3D matrix (rows x columns x 3) containing the number of
%    points used to quantify length, pennation, and curvature in each tract
%
%  apo_area: A 2D matrix (rows x columns) containing the amount of
%    apoeurosis area represented by each fiber tract
%
%
%OTHER FUNCTIONS IN THE MUSCLE DTI FIBER-TRACKING TOOLBOX
%  For help with anisotropic smoothing, see <a href="matlab: help aniso4D_smoothing">aniso4D_smoothing</a>.
%  For help calculating the diffusion tensor, see <a href="matlab: help signal2tensor2">signal2tensor2</a>.
%  For help defining the muscle mask, see <a href="matlab: help define_muscle">define_muscle</a>.
%  For help defining the aponeurosis ROI, see <a href="matlab: help define_roi">define_roi</a>.
%  For help with fiber tracking, see <a href="matlab: help fiber_track">fiber_track</a>.
%  For help smoothing fiber tracts, see <a href="matlab: help fiber_smoother">fiber_smoother</a>.
%  For help selecting fiber tracts following their quantification, see <a href="matlab: help fiber_goodness">fiber_goodness</a>.
%  For help visualizing fiber tracts and other structures, see <a href="matlab: help fiber_visualizer">fiber_visualizer</a>.
%
% VERSION INFORMATION
%  v. 1.0.0 (initial release), 17 Jan 2021, Bruce Damon
%  v. 2.0.0 ensured compatibility with new fiber_all matrix structures;
%           added calculation of additional orientation angles
%
% ACKNOWLEDGEMENTS
%  People: Zhaohua Ding, Adam Anderson, Anneriet Heemskerk
%  Grant support: NIH/NIAMS R01 AR050101, NIH/NIAMS R01 AR073831

%% get options out of the input structure

% get resolution parameters for later unit conversions
dwi_res = fq_options.dwi_res;
dwi_slicethickness = dwi_res(3);
dwi_fov = dwi_res(1);
dwi_xsize = dwi_res(2);

% convert fiber tracts to mm, if needed; roi_mesh comes later
if strcmp(fq_options.tract_units, 'vx') || strcmp(fq_options.tract_units, 'VX')
    fiber_all_mm(:,:,:,1) = fiber_all(:,:,:,1)*(dwi_fov/dwi_xsize);
    fiber_all_mm(:,:,:,2) = fiber_all(:,:,:,2)*(dwi_fov/dwi_xsize);
    fiber_all_mm(:,:,:,3) = fiber_all(:,:,:,3)*dwi_slicethickness;
elseif strcmp(fq_options.tract_units, 'mm') || strcmp(fq_options.tract_units, 'MM')
    fiber_all_mm = fiber_all;
else
    beep
    error('Aborting fiber_quantifier because of unexpected units for fiber tracts.')
end

% find out the seeding method
if isfield(fq_options, 'seed_method')                                       %if the seeding method is specified in fq_options
    seed_method = fq_options.seed_method;
    seed_method = seed_method(1);
else                                                                        %default is aponeurosis; preserves backwards compatibility
    seed_method = 'a';  %Change here and in line 286
end

%% measure muscle's central axis

% get mask dimensions, in mm, across the slices, columns, and rows
mask_sum_slice = squeeze(sum(sum(mask)));
mask_slices(1) = find(mask_sum_slice, 1);
mask_slices(2) = find(mask_sum_slice, 1, 'last');
distance_slices = (diff(mask_slices)+1)*dwi_slicethickness;

mask_sum_cols = squeeze(sum(sum(mask,3)));
mask_cols(1) = find(mask_sum_cols, 1);
mask_cols(2) = find(mask_sum_cols, 1, 'last');
distance_cols = (diff(mask_cols)+1)*(dwi_res(1)/dwi_res(2));

mask_sum_rows = squeeze(sum(sum(mask,3),2));
mask_rows(1) = find(mask_sum_rows, 1);
mask_rows(2) = find(mask_sum_rows, 1, 'last');
distance_rows = (diff(mask_rows)+1)*(dwi_res(1)/dwi_res(2));

max_distance = max([distance_rows distance_cols distance_slices]);
max_distance_idx = find([distance_rows distance_cols distance_slices]==max_distance);
distance_idx_all = [mask_rows; mask_cols; mask_slices];

% find centroids along smallest two dimensions/fit to 3rd order polynomial
centroids_all = zeros(size(mask,max_distance_idx),3);
if max_distance_idx==1                                                      %greatest length is in the row direction

    for k=distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2)
        loop_mask_slc = sum(squeeze(mask(k,:,:)),1);                        %sum over slices
        loop_mask_slc(loop_mask_slc>0) = 1;
        loop_mask_col = sum(squeeze(mask(k,:,:)),2);                        %sum over columns
        loop_mask_col(loop_mask_col>0) = 1;
        centroids_all(k,:) = [0 mean(find(loop_mask_col)) mean(find(loop_mask_slc))]; %find mean column and slice positions; store in matrix

    end

    % fit observed centroids to third order polynomials as functions of distance along the row direction
    centroids_all(:,max_distance_idx) = 1:size(centroids_all,1);
    centroid_axis_params_sr = polyfit(centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx),...
        centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 3), 3);
    centroid_axis_params_cr = polyfit(centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx),...
        centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 2), 3);

    centroids_fitted_all = centroids_all;
    centroids_fitted_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 2) = ...
        polyval(centroid_axis_params_cr, centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx));
    centroids_fitted_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 3) = ...
        polyval(centroid_axis_params_sr, centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx));

elseif max_distance_idx==2                                                      %greatest length is in the column direction

    for k=distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2)
        loop_mask_slc = sum(squeeze(mask(:,k,:)),1);                        %sum over slices
        loop_mask_slc(loop_mask_slc>0) = 1;
        loop_mask_row = sum(squeeze(mask(:,k,:)),2);                        %sum over rows
        loop_mask_row(loop_mask_row>0) = 1;
        centroids_all(k,:) = [mean(find(loop_mask_row)) 0 mean(find(loop_mask_slc))];
    end

    % fit observed centroids to third order polynomials as functions of distance along the column direction
    centroids_all(:,max_distance_idx) = 1:size(centroids_all,1);
    centroid_axis_params_sc = polyfit(centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx),...
        centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 3), 3);
    centroid_axis_params_rc = polyfit(centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx),...
        centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 1), 3);

    centroids_fitted_all = centroids_all;
    centroids_fitted_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 1) = ...
        polyval(centroid_axis_params_rc, centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx));
    centroids_fitted_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 3) = ...
        polyval(centroid_axis_params_sc, centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx));

else                                                                          %greatest length is in the slice direction

    for k=distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2)
        loop_mask_col = sum(squeeze(mask(:,:,k)),1);                        %sum over columns
        loop_mask_col(loop_mask_col>0) = 1;
        loop_mask_row = sum(squeeze(mask(:,:,k)),2);                        %sum over rows
        loop_mask_row(loop_mask_row>0) = 1;
        centroids_all(k,:) = [mean(find(loop_mask_row)) mean(find(loop_mask_col)) 0];
    end

    % fit observed centroids to third order polynomials as functions of distance along the slice direction
    centroids_all(:,max_distance_idx) = 1:size(centroids_all,1);
    centroid_axis_params_cs = polyfit(centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx),...
        centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 2), 3);
    centroid_axis_params_rs = polyfit(centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx),...
        centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 1), 3);

    centroids_fitted_all = centroids_all;
    centroids_fitted_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 1) = ...
        polyval(centroid_axis_params_rs, centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx));
    centroids_fitted_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), 2) = ...
        polyval(centroid_axis_params_cs, centroids_all(distance_idx_all(max_distance_idx,1):distance_idx_all(max_distance_idx,2), max_distance_idx));

end

centroids_fitted_all(:,1:2) = centroids_fitted_all(:,1:2)*(dwi_fov/dwi_xsize);
centroids_fitted_all(:,3) = centroids_fitted_all(:,3)*dwi_slicethickness;
centroids_diff_all = diff(centroids_fitted_all);
centroids_diff_all(1:distance_idx_all(max_distance_idx,1)-1,:) = 0;
centroids_diff_all(distance_idx_all(max_distance_idx,2):end,:) = 0;
for k=1:length(centroids_diff_all(:,1))
    if sum(centroids_diff_all(k,:))>0
        centroids_diff_all(k,:) = centroids_diff_all(k,:)/norm(centroids_diff_all(k,:));
    end
end


%% fiber quantification loops

switch seed_method

    case{'a'} 
        filt_kernel = fq_options.filt_kernel;

        % calculate fiber lengths in points
        fiber_length = squeeze(fiber_all(:,:,:,1));
        fiber_length(fiber_length>0)=1;
        fiber_length=sum(fiber_length, 3);

        % initialize output variables
        angle_list = zeros(size(squeeze(fiber_all)));
        distance_list = zeros(size(squeeze(fiber_all(:,:,:,1))));
        curvature_list = zeros(size(squeeze(fiber_all(:,:,:,1))));
        n_points = zeros([size(squeeze(fiber_all(:,:,1,1))) 3]);
        apo_area = zeros(size(squeeze(roi_mesh(:,:,1))));

        % convert roi mesh to mm, if needed
        if strcmp(fq_options.mesh_units, 'vx') || strcmp(fq_options.mesh_units, 'VX')
            roi_mesh_mm(:,:,1) = roi_mesh(:,:,1)*(dwi_fov/dwi_xsize);                                   %switch row column to X-Y frame of reference
            roi_mesh_mm(:,:,2) = roi_mesh(:,:,2)*(dwi_fov/dwi_xsize);
            roi_mesh_mm(:,:,3) = roi_mesh(:,:,3)*dwi_slicethickness;
        elseif strcmp(fq_options.mesh_units, 'mm') || strcmp(fq_options.mesh_units, 'MM')
            roi_mesh_mm = roi_mesh;
        else
            beep
            error('Aborting fiber_quantifier because of unexpected units for roi mesh.')
        end

        % prepare for pennation measurements by finding the slopes of the tangent lines

        % pre-allocate memory space
        dx_dy = zeros(length(roi_mesh_mm(:,1,1)), length(roi_mesh_mm(1,:,1))-1);    %form a zeros matrix to hold dx/dz
        dy_dz = zeros(length(roi_mesh_mm(:,1,1))-1, length(roi_mesh_mm(1,:,1)));    %form a zeros matrix to hold dy/dz

        for row_cntr = 1:length(roi_mesh_mm(:,1,1))
            inplane_x = squeeze(roi_mesh_mm(row_cntr,:, 2));                        %find the x positions (=column positions of roi_mesh)
            inplane_y = squeeze(roi_mesh_mm(row_cntr,:, 1));                        %find the y positions (=row positions of roi_mesh)
            dx_dy(row_cntr,:) = diff(inplane_x)./diff(inplane_y);                   %calculate approximate derivative as delta X / delta Y
        end
        dx_dy(:,length(roi_mesh_mm(1,:,1)))=dx_dy(:,end);                           %approximate final column as the column to its left

        for col_cntr = 1:length(roi_mesh_mm(1,:,1))
            thruplane_y = squeeze(roi_mesh_mm(:, col_cntr, 1));                     %find the y positions
            thruplane_z = squeeze(roi_mesh_mm(:, col_cntr, 3));                     %find the z positions
            dy_dz(:,col_cntr) = diff(thruplane_y)./diff(thruplane_z);               %calculate approximate derivative as delta Y / delta Z
        end
        dy_dz(length(roi_mesh_mm(:,1,1)),:)=dy_dz(end,:);                                              %approximate final row as the row above it

        %median filter the slopes using user-defined kernel size
        dx_dy = medfilt2(dx_dy, [filt_kernel filt_kernel]);
        dy_dz = medfilt2(dy_dz, [filt_kernel filt_kernel]);

        % architectural measurements

        %median filtering eliminates edge information, so adjust for the kernel
        %size when looping through the mesh for architectural measurements
        start_row = 1;
        start_col = 1;
        end_row = length(roi_mesh(:,1,1)) - floor(filt_kernel/2);
        end_col = length(roi_mesh(1,:,1)) - floor(filt_kernel/2);

        % begin the architecture measurement loops
        for row_cntr = start_row:end_row

            for col_cntr = start_col:end_col

                %aponeurosis area calculations
                Q0=squeeze(roi_mesh_mm(row_cntr, col_cntr,1:3));                                    %p0-3 are the four points of the quadrilateral on the roi mesh
                Q1=squeeze(roi_mesh_mm(row_cntr+1, col_cntr,1:3));                                  %p0-3 are the four points of the quadrilateral on the roi mesh
                Q2=squeeze(roi_mesh_mm(row_cntr+1, col_cntr+1,1:3));                                %p0-3 are the four points of the quadrilateral on the roi mesh
                Q3=squeeze(roi_mesh_mm(row_cntr, col_cntr+1,1:3));                                  %p0-3 are the four points of the quadrilateral on the roi mesh
                apo_area(row_cntr, col_cntr) = ...                                                  %model the quadrilateral as two irregular triangles with vertices v0-v1-v2 and v2-v3-v0
                    norm(cross((Q1-Q0), (Q2-Q1)))/2 + norm(cross((Q3-Q2), (Q3-Q0)))/2;              %their area is 1/2 of the magnitude of the indicated cross products

                %find initial point
                seed_point_mm = squeeze(fiber_all_mm(row_cntr, col_cntr, :, :));
                seed_point_mm = seed_point_mm(find(seed_point_mm(:,1), 1), :);
                if sum(sum(seed_point_mm))==0
                    continue
                end

                % find centroid's direction vector at the seed point
                centroid_idx = find(centroids_fitted_all(:,max_distance_idx)>=seed_point_mm(max_distance_idx), 1);
                c_vector = centroids_diff_all(centroid_idx,:);
                c_vector = c_vector/norm(c_vector);                                          	%convert to unit vector

                if fiber_length(row_cntr,col_cntr) >= 6                                           	%quantify all tracts of at least 6 points

                    %find initial point
                    seed_point = squeeze(fiber_all_mm(row_cntr, col_cntr, 1, :));
                    Tx0 = seed_point(2);
                    Ty0 = seed_point(1);
                    Tz0 = seed_point(3);

                    %get the tangent line in the in-plane direction from the matrix
                    %calculated above
                    local_dxdy = dx_dy(row_cntr,col_cntr);                                          %local value of the slope, dx/dz
                    local_xy_intrcpt = Tx0 - local_dxdy*Ty0;                                        %calculate the intercept by rearranging x = b + (dx/dz)*z to solve for the intercept b

                    %get the tangent line in the through-plane direction:
                    local_dydz = dy_dz(row_cntr,col_cntr);                                          %local value of the slope, dy/dz
                    local_yz_intrcpt = Ty0 - local_dydz*Tz0;                                      	%calculate the intercept by rearranging y = b + (dy/dz)*z to solve for the intercept b

                    %find two other points in the tangent plane
                    Ty1 = Ty0 - 1;
                    Tz1 = Tz0;
                    Tx1 = local_xy_intrcpt + local_dxdy*Ty1;

                    Tx2 = Tx0;
                    Tz2 = Tz0 - 1;
                    Ty2 = local_yz_intrcpt + local_dydz*Tz2;

                    %calculate the Cartesian equation for the plane and the unit normal vector
                    T_0 = seed_point;
                    T_1 = [Ty1 Tx1 Tz1]';
                    T_2 = [Ty2 Tx2 Tz2]';
                    dT1 = T_1 - T_0;
                    dT2 = T_2 - T_0;
                    n_vector = cross(dT1, dT2);
                    n_vector = n_vector/norm(n_vector);                                          	%convert to unit vector

                    %find the fiber length, pennation angle, and curvature as a function of position along the fiber:
                    for fiber_cntr = 2:fiber_length(row_cntr,col_cntr)

                        %fiber length
                        delta_p = squeeze(fiber_all_mm(row_cntr, col_cntr, fiber_cntr, :)) - ...
                            squeeze(fiber_all_mm(row_cntr,col_cntr, fiber_cntr-1, :));             	%form position vector from preceding point in the tract
                        distance_list(row_cntr,col_cntr,fiber_cntr)  =  ...                         %Euclidean distance from preceding point + the preceding point
                            sqrt(sum(delta_p.^2)) + distance_list(row_cntr,col_cntr,fiber_cntr-1);

                        %pennation measurements for each point on the tract
                        r_vector = squeeze(fiber_all_mm(row_cntr, col_cntr, fiber_cntr, :)) - ...       %form position vectors along the tract
                            seed_point;
                        r_vector = r_vector/norm(r_vector);                                          	%convert to unit vector

                        theta_degrees = asind(dot(r_vector, n_vector));                    	%theta is the complement to that formed by the normal vector and the position vector
                        if theta_degrees <0 || theta_degrees >90                                        %account for direction of normal vector
                            theta_degrees = asind(dot(r_vector, -n_vector));
                        end

                        alpha_degrees = acosd(dot(r_vector, c_vector));                    	        %alpha is the complement to that formed by the normal vector and the position vector
                        if alpha_degrees <0 || alpha_degrees >90                                    %account for direction of normal vector
                            alpha_degrees = asind(dot(r_vector, -c_vector));
                        end

                        angle_list(row_cntr,col_cntr,fiber_cntr,1) = alpha_degrees;                  	%write to matrix
                        if isnan(angle_list(row_cntr,col_cntr,fiber_cntr,1))                         	%in case of dividing by zero
                            angle_list(row_cntr,col_cntr,fiber_cntr,1) = 0;
                        end

                        angle_list(row_cntr,col_cntr,fiber_cntr,2) = theta_degrees;                  	%write to matrix
                        if isnan(angle_list(row_cntr,col_cntr,fiber_cntr,2))                         	%in case of dividing by zero
                            angle_list(row_cntr,col_cntr,fiber_cntr,2) = 0;
                        end

                        angle_list(row_cntr,col_cntr,fiber_cntr,3) = alpha_degrees - theta_degrees;  %beta = theta - alpha

                        %keep track of number of points quantified.
                        n_points(row_cntr,col_cntr,1) = fiber_cntr;                                 %In 3rd dimension, save #points for distance data in level 1
                        n_points(row_cntr,col_cntr,2) = fiber_cntr-1;                               %In 3rd dimension, save #points for pennation data in level 2;
                        %use fiber_cntr-1 because measurements start at point #2

                        if fiber_cntr>2 && fiber_cntr<(fiber_length(row_cntr,col_cntr)-3)           %curvature values blow up at the end of the fiber because the rest of the vector is padded with 0's

                            %curvature measurements use a discrete implementation of the Frenet equations.
                            p1_idx = fiber_cntr-1;                                                  %indices for the three points of interest along the tract - define two pairs of points
                            p2_idx = fiber_cntr;
                            p3_idx = fiber_cntr+1;
                            loop_fiber_m = squeeze(fiber_all_mm(row_cntr,col_cntr,:,:))/1000;      	%convert from mm to m for curvature measurements

                            delta_p1 = (loop_fiber_m(p1_idx,:))-loop_fiber_m(1,:);                       %three position vectors, one for each point
                            delta_p2 = (loop_fiber_m(p2_idx,:))-loop_fiber_m(1,:);
                            delta_p3 = (loop_fiber_m(p3_idx,:))-loop_fiber_m(1,:);

                            ds21 = sqrt(sum((loop_fiber_m(p2_idx,:)-loop_fiber_m(p1_idx,:)).^2));   %distance between points 1 and 2 and (below) 2 and 3
                            ds32 = sqrt(sum((loop_fiber_m(p3_idx,:)-loop_fiber_m(p2_idx,:)).^2));

                            tangent_vector_2 = (delta_p2-delta_p1)/norm(delta_p2-delta_p1);                           	%normalized tangent lines between the two pairs of points
                            tangent_vector_3 = (delta_p3-delta_p2)/norm(delta_p3-delta_p2);
                            dTds = ((tangent_vector_3-tangent_vector_2)/mean([ds21 ds32]))';      	%dT/ds is the spatial rate of change in tangent lines
                            dTds(isnan(dTds)) = 0;

                            if sum(dTds) ~= 0
                                N_vector = dTds/norm(dTds);                                         %normal to tangent lines
                                curvature_list(row_cntr,col_cntr,fiber_cntr) = pinv(N_vector)*dTds;	%based on dT/ds = curvature * N
                            end

                            n_points(row_cntr,col_cntr,3) = fiber_cntr-1;                           %In 3rd dimension, save # points used for curvature data in level 3

                        end                                                                         %of curvature if statement

                    end                                                                             %of inside fiber loop

                end                                                                                 %of outside fiber loop

            end                                                                                     %of column loop

        end                                                                                         %of row loop



        %%%%%%%%% End of aponeurosis methods   %%%%%%%%%%

    otherwise % voxel or planar seeding methods

        % calculate fiber lengths in points
        fiber_length = fiber_all(:,:,:,1);
        fiber_length(fiber_length>0)=1;
        fiber_length=sum(fiber_length, 3);

        % initialize output variables
        angle_list = zeros(size(fiber_all(:,:,:,1)));
        distance_list = zeros(size(fiber_all(:,:,:,1)));
        curvature_list = zeros(size(fiber_all(:,:,:,1)));
        n_points = zeros([size(fiber_all(:,:,1,1)) 3]);
        apo_area = zeros(size(roi_mesh(:,:,1)));

        % begin the architecture measurement loops
        for seed_cntr = 1:length(fiber_all_mm(:,1,1,1))

            for plane_cntr = 1:length(fiber_all_mm(1,:,1,1))

                %find initial point
                seed_point_mm = squeeze(fiber_all_mm(seed_cntr, plane_cntr, :, :));
                seed_point_mm = seed_point_mm(find(seed_point_mm(:,max_distance_idx), 1), :);
                if sum(sum(seed_point_mm))==0
                    continue
                end

                % find centroid's direction vector at the seed point
                centroid_idx = find(centroids_fitted_all(:,max_distance_idx)>=seed_point_mm(max_distance_idx), 1);
                c_vector = centroids_diff_all(centroid_idx,:);
                c_vector = c_vector/norm(c_vector);

                if fiber_length(seed_cntr,plane_cntr) >= 6                                           	%quantify all tracts of at least 6 points

                    %find the fiber length, pennation angle, and curvature as a function of position along the fiber:
                    for fiber_cntr = 2:fiber_length(seed_cntr,plane_cntr)

                        %fiber length
                        delta_p = squeeze(fiber_all_mm(seed_cntr, plane_cntr, fiber_cntr, :)) - ...
                            squeeze(fiber_all_mm(seed_cntr,plane_cntr, fiber_cntr-1, :));             	%form position vector from preceding point in the tract
                        distance_list(seed_cntr,plane_cntr,fiber_cntr)  =  ...                         %Euclidean distance from preceding point + the preceding point
                            sqrt(sum(delta_p.^2)) + distance_list(seed_cntr,plane_cntr,fiber_cntr-1);

                        %pennation measurements for each point on the tract
                        r_vector = squeeze(fiber_all_mm(seed_cntr, plane_cntr, fiber_cntr, :))' - ...   %form position vectors along the tract
                            seed_point_mm;
                        r_vector = r_vector/norm(r_vector);                                          	%r_unit is the unit vector
                        alpha_degrees = acosd(dot(r_vector, c_vector));                    	%pennation angle is the complement to that formed by the normal vector and the position vector
                        if alpha_degrees <0 || alpha_degrees >90                                    %account for direction of normal vector
                            alpha_degrees = asind(dot(r_vector, -c_vector));
                        end

                        angle_list(seed_cntr,plane_cntr,fiber_cntr) = alpha_degrees;                  	%write to matrix
                        if isnan(angle_list(seed_cntr,plane_cntr,fiber_cntr))                         	%in case of dividing by zero
                            angle_list(seed_cntr,plane_cntr) = 0;
                        end

                        %keep track of number of points quantified.
                        n_points(seed_cntr,plane_cntr,1) = fiber_cntr;                                 %In 3rd dimension, save #points for distance data in level 1
                        n_points(seed_cntr,plane_cntr,2) = fiber_cntr-1;                               %In 3rd dimension, save #points for pennation data in level 2;
                        %use fiber_cntr-1 because measurements start at point #2

                        if fiber_cntr>2 && fiber_cntr<(fiber_length(seed_cntr,plane_cntr)-3)           %curvature values blow up at the end of the fiber because the rest of the vector is padded with 0's

                            %curvature measurements use a discrete implementation of the Frenet equations.
                            p1_idx = fiber_cntr-1;                                                  %indices for the three points of interest along the tract - define two pairs of points
                            p2_idx = fiber_cntr;
                            p3_idx = fiber_cntr+1;
                            loop_fiber_m = squeeze(fiber_all_mm(seed_cntr,plane_cntr,:,:))/1000;      	%convert from mm to m for curvature measurements

                            delta_p1 = (loop_fiber_m(p1_idx,:))-loop_fiber_m(1,:);                       %three position vectors, one for each point
                            delta_p2 = (loop_fiber_m(p2_idx,:))-loop_fiber_m(1,:);
                            delta_p3 = (loop_fiber_m(p3_idx,:))-loop_fiber_m(1,:);

                            ds21 = sqrt(sum((loop_fiber_m(p2_idx,:)-loop_fiber_m(p1_idx,:)).^2));   %distance between points 1 and 2 and (below) 2 and 3
                            ds32 = sqrt(sum((loop_fiber_m(p3_idx,:)-loop_fiber_m(p2_idx,:)).^2));

                            tangent_vector_2 = (delta_p2-delta_p1)/norm(delta_p2-delta_p1);                           	%normalized tangent lines between the two pairs of points
                            tangent_vector_3 = (delta_p3-delta_p2)/norm(delta_p3-delta_p2);
                            dTds = ((tangent_vector_3-tangent_vector_2)/mean([ds21 ds32]))';      	%dT/ds is the spatial rate of change in tangent lines
                            dTds(isnan(dTds)) = 0;

                            if sum(dTds) ~= 0
                                N_vector = dTds/norm(dTds);                                         %normal to tangent lines
                                curvature_list(seed_cntr,plane_cntr,fiber_cntr) = pinv(N_vector)*dTds;	%based on dT/ds = curvature * N
                            end

                            n_points(seed_cntr,plane_cntr,3) = fiber_cntr-2;                           %In 3rd dimension, save # points used for curvature data in level 3. use -2 instead of -1 because of duplicate seed point

                        end                                                                         %of curvature if statement

                    end                                                                             %of plane number loop

                end                                                                                 %of seed point loop

            end                                                                                     %of column loop

        end                                                                                         %of other seeding methods case statement
end

%% end the function

return;
